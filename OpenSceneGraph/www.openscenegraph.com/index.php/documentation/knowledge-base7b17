<?xml version="1.0" encoding="utf-8"?>
<!-- generator="Joomla! - Open Source Content Management" -->
<feed xmlns="http://www.w3.org/2005/Atom"  xml:lang="en-gb">
	<title type="text">Knowledge Base</title>
	<subtitle type="text">Project website for OpenSceneGraph</subtitle>
	<link rel="alternate" type="text/html" href="https://www.openscenegraph.com"/>
	<id>https://www.openscenegraph.com/index.php/documentation/knowledge-base</id>
	<updated>2024-01-24T17:06:31+00:00</updated>
	<author>
		<name>OpenSceneGraph</name>
		<email>robert@openscenegraph.com</email>
	</author>
	<generator uri="https://www.joomla.org">Joomla! - Open Source Content Management</generator>
	<link rel="self" type="application/atom+xml" href="https://www.openscenegraph.com/index.php/documentation/knowledge-base?format=feed&amp;type=atom"/>
	<entry>
		<title>Delaunay Constraint</title>
		<link rel="alternate" type="text/html" href="https://www.openscenegraph.com/index.php/documentation/knowledge-base/74-delaunay-constraint"/>
		<published>2012-10-03T00:25:40+00:00</published>
		<updated>2012-10-03T00:25:40+00:00</updated>
		<id>https://www.openscenegraph.com/index.php/documentation/knowledge-base/74-delaunay-constraint</id>
		<author>
			<name>openscenegraph</name>
			<email>jtorresfabra@gmail.com</email>
		</author>
		<summary type="html">&lt;p&gt;A Delaunay Constraint (DC) is a class for defining some edges which must be retained in a delaunay triangulation.&lt;/p&gt;
&lt;p&gt;DC is derived from Geometry, so it can consist of one or more LINE_STRIPs or LINE_LOOPs. The final triangulation will include these lines as edges in the triangulated mesh.&lt;/p&gt;
&lt;p&gt;Utility functions allow the triangles inside the DC to be deleted (actually the triangles are moved to the DC) - this allows holes to be formed in the terrain. You can then take the triangles in the DC and create a new Geometry which will replace the terrain area, perhaps with a different texture (for example replace a lake area with a water texture in a general terrain).&lt;/p&gt;
&lt;p&gt;Or you can derive from DC to make your own geometry replacement method - I have created a 'forest' generator where the forest geometry is formed by raising the removed polygons (by the height of the forest) and building a wall around the edge of the forest (and using sensible textures of course).&lt;/p&gt;
&lt;p&gt;Other uses: roads railways rivers fields house with a garden around it. .....&lt;/p&gt;</summary>
		<content type="html">&lt;p&gt;A Delaunay Constraint (DC) is a class for defining some edges which must be retained in a delaunay triangulation.&lt;/p&gt;
&lt;p&gt;DC is derived from Geometry, so it can consist of one or more LINE_STRIPs or LINE_LOOPs. The final triangulation will include these lines as edges in the triangulated mesh.&lt;/p&gt;
&lt;p&gt;Utility functions allow the triangles inside the DC to be deleted (actually the triangles are moved to the DC) - this allows holes to be formed in the terrain. You can then take the triangles in the DC and create a new Geometry which will replace the terrain area, perhaps with a different texture (for example replace a lake area with a water texture in a general terrain).&lt;/p&gt;
&lt;p&gt;Or you can derive from DC to make your own geometry replacement method - I have created a 'forest' generator where the forest geometry is formed by raising the removed polygons (by the height of the forest) and building a wall around the edge of the forest (and using sensible textures of course).&lt;/p&gt;
&lt;p&gt;Other uses: roads railways rivers fields house with a garden around it. .....&lt;/p&gt;</content>
		<category term="Knowledge Base" />
	</entry>
	<entry>
		<title>Language Wrappers</title>
		<link rel="alternate" type="text/html" href="https://www.openscenegraph.com/index.php/documentation/knowledge-base/95-language-wrappers"/>
		<published>2013-02-01T01:48:36+00:00</published>
		<updated>2013-02-01T01:48:36+00:00</updated>
		<id>https://www.openscenegraph.com/index.php/documentation/knowledge-base/95-language-wrappers</id>
		<author>
			<name>openscenegraph</name>
			<email>jtorresfabra@gmail.com</email>
		</author>
		<summary type="html">&lt;h3 id=&quot;osgswig&quot;&gt;osgswig&lt;/h3&gt;
&lt;p&gt;&lt;a class=&quot;ext-link&quot; href=&quot;http://code.google.com/p/osgswig/&quot;&gt;&lt;span class=&quot;icon&quot;&gt;osgswig&lt;/span&gt;&lt;/a&gt; - Language wrappings for OpenSceneGraph generated by &lt;a class=&quot;ext-link&quot; href=&quot;http://www.swig.org/&quot;&gt;&lt;span class=&quot;icon&quot;&gt;SWIG&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SWIG is a popular wrapper and interface generator, which uses common interface files to wrap for multiple target languages. Osgswig's current focus is on Python, Ruby and Java bindings, but other SWIG &lt;a class=&quot;ext-link&quot; href=&quot;http://www.swig.org/compat.html#SupportedLanguages&quot;&gt;&lt;span class=&quot;icon&quot;&gt;supported languages&lt;/span&gt;&lt;/a&gt; such as Lua and C# are optional. All standard OSG nodekits are supported and Windows &lt;a class=&quot;ext-link&quot; href=&quot;http://code.google.com/p/osgswig/downloads/list&quot;&gt;&lt;span class=&quot;icon&quot;&gt;installers&lt;/span&gt;&lt;/a&gt; are made available for recent stable releases (e.g. v2.2.0). Because of semi-automatic and manual interface file creation, SWIG and target language limitations, it is not technically feature complete. (License: MIT)&lt;/p&gt;
&lt;h3 id=&quot;osgDotNet&quot;&gt;osgDotNet&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.openscenegraph.org/projects/osgDotNet&quot;&gt;osgDotNet&lt;/a&gt; - C#/.NET wrappers for OpenSceneGraph&lt;/p&gt;
&lt;p&gt;osgDotNet supports OpenSceneGraph 2.0 including all core libraries. Extension of wrapper classes via subclassing in C# is also supported. osgDotNet is a static binding of the OpenSceneGraph API that is generated using osgIntrospection. The generator application is licensed under the GNU GPL; the wrappers themselves are licensed at the user's discretion.&lt;/p&gt;
&lt;p&gt;Better solution is use C++/CLI to write your application with most powerful .NET framework but also with native &lt;a class=&quot;wiki&quot; href=&quot;http://www.openscenegraph.org/projects/osg/wiki/OpenSceneGraph&quot;&gt;OpenSceneGraph&lt;/a&gt; C++ class support. See the osgCppCLIDemo.rar attached.&lt;/p&gt;
&lt;h3 id=&quot;JavaOSG&quot;&gt;JavaOSG&lt;/h3&gt;
&lt;p&gt;&lt;a class=&quot;ext-link&quot; href=&quot;http://www.noodleglue.org/noodleglue/javaOsg.html&quot;&gt;&lt;span class=&quot;icon&quot;&gt;JavaOSG&lt;/span&gt;&lt;/a&gt; - Java wrappers for the OpenSceneGraph (License : GNU LGPL)&lt;/p&gt;
&lt;p&gt;Bindings for theÂ  release (1.00) of all core osg libraries and Producer. Virtually all the classes and methods are accessible, and allows sub-classing of Referenced classes in Java. Includes examples using Producer's native windowing and also embedding the GL context in a Java JFrame.&lt;/p&gt;
&lt;h3 id=&quot;pyOSG&quot;&gt;pyOSG&lt;/h3&gt;
&lt;p&gt;&lt;a class=&quot;ext-link&quot; href=&quot;http://code.astraw.com/projects/pyosg/&quot;&gt;&lt;span class=&quot;icon&quot;&gt;pyOSG&lt;/span&gt;&lt;/a&gt; - Python wrappers for the OpenSceneGraph. Uses Boost Python(License : GNU LGPL)&lt;/p&gt;
&lt;h3 id=&quot;osgTcl&quot;&gt;osgTcl&lt;/h3&gt;
&lt;p&gt;A tiny Tcl wrapper based on &lt;strong&gt;osgIntrospection&lt;/strong&gt;. Download: &lt;a class=&quot;attachment&quot; href=&quot;http://www.openscenegraph.org/projects/osg/attachment/wiki/Community/LanguageWrappers/osgTcl.tar.gz&quot; title=&quot;Attachment 'osgTcl.tar.gz' in Community/LanguageWrappers&quot;&gt;osg osgTcl.tar.gz&lt;/a&gt; NB under WinXP (at least) this link downloads as osgTcl.tar.tar which errors when winzip tries to open it. Save the download file to disk, rename to osgTcl.tar.gz and winzip will open it. NB 10.03.07 the code refers to node.take - this method is equivalent to node.release. I have managed to load a model and created a SceneView object then rendering a simple scene in a Tcl3d window is easy (geoffm). Any chance of a Producer or better tk window widget?&lt;/p&gt;
&lt;h3 id=&quot;Lua&quot;&gt;Lua&lt;/h3&gt;
&lt;p&gt;Experimental prototypes of wrapping with &lt;a class=&quot;ext-link&quot; href=&quot;http://www.lua.org/&quot;&gt;&lt;span class=&quot;icon&quot;&gt;Lua&lt;/span&gt;&lt;/a&gt; are being developed under the &lt;a class=&quot;ext-link&quot; href=&quot;http://sourceforge.net/projects/osgtoy&quot;&gt;&lt;span class=&quot;icon&quot;&gt;osgToy&lt;/span&gt;&lt;/a&gt; project. (The experiment is at its barest beginnings; I just wanted to mention here as notice of activity on this front)&lt;/p&gt;
&lt;h3 id=&quot;osgLua&quot;&gt;osgLua&lt;/h3&gt;
&lt;p&gt;A full-featured and complete Lua wrapper based on osgIntrospection. osgLua checks in run-time osgIntrospection to instance any reflected class. SVN-Repository &lt;a class=&quot;ext-link&quot; href=&quot;http://svn.pplux.com/lab/osgLua&quot;&gt;&lt;span class=&quot;icon&quot;&gt;http://svn.pplux.com/lab/osgLua&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;CamlOSG&quot;&gt;CamlOSG&lt;/h3&gt;
&lt;p&gt;&lt;a class=&quot;ext-link&quot; href=&quot;http://camlosg.sourceforge.net/&quot;&gt;&lt;span class=&quot;icon&quot;&gt;CamlOSG&lt;/span&gt;&lt;/a&gt; - Objective Caml wrappers for the OpenSceneGraph (License : GNU LGPL)&lt;/p&gt;
&lt;p&gt;Bindings are done by hand (without using of osgIntrospection) and are fairly incomplete. But it is simple to add the necessary binding. Just look at the sources for example.&lt;/p&gt;</summary>
		<content type="html">&lt;h3 id=&quot;osgswig&quot;&gt;osgswig&lt;/h3&gt;
&lt;p&gt;&lt;a class=&quot;ext-link&quot; href=&quot;http://code.google.com/p/osgswig/&quot;&gt;&lt;span class=&quot;icon&quot;&gt;osgswig&lt;/span&gt;&lt;/a&gt; - Language wrappings for OpenSceneGraph generated by &lt;a class=&quot;ext-link&quot; href=&quot;http://www.swig.org/&quot;&gt;&lt;span class=&quot;icon&quot;&gt;SWIG&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SWIG is a popular wrapper and interface generator, which uses common interface files to wrap for multiple target languages. Osgswig's current focus is on Python, Ruby and Java bindings, but other SWIG &lt;a class=&quot;ext-link&quot; href=&quot;http://www.swig.org/compat.html#SupportedLanguages&quot;&gt;&lt;span class=&quot;icon&quot;&gt;supported languages&lt;/span&gt;&lt;/a&gt; such as Lua and C# are optional. All standard OSG nodekits are supported and Windows &lt;a class=&quot;ext-link&quot; href=&quot;http://code.google.com/p/osgswig/downloads/list&quot;&gt;&lt;span class=&quot;icon&quot;&gt;installers&lt;/span&gt;&lt;/a&gt; are made available for recent stable releases (e.g. v2.2.0). Because of semi-automatic and manual interface file creation, SWIG and target language limitations, it is not technically feature complete. (License: MIT)&lt;/p&gt;
&lt;h3 id=&quot;osgDotNet&quot;&gt;osgDotNet&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.openscenegraph.org/projects/osgDotNet&quot;&gt;osgDotNet&lt;/a&gt; - C#/.NET wrappers for OpenSceneGraph&lt;/p&gt;
&lt;p&gt;osgDotNet supports OpenSceneGraph 2.0 including all core libraries. Extension of wrapper classes via subclassing in C# is also supported. osgDotNet is a static binding of the OpenSceneGraph API that is generated using osgIntrospection. The generator application is licensed under the GNU GPL; the wrappers themselves are licensed at the user's discretion.&lt;/p&gt;
&lt;p&gt;Better solution is use C++/CLI to write your application with most powerful .NET framework but also with native &lt;a class=&quot;wiki&quot; href=&quot;http://www.openscenegraph.org/projects/osg/wiki/OpenSceneGraph&quot;&gt;OpenSceneGraph&lt;/a&gt; C++ class support. See the osgCppCLIDemo.rar attached.&lt;/p&gt;
&lt;h3 id=&quot;JavaOSG&quot;&gt;JavaOSG&lt;/h3&gt;
&lt;p&gt;&lt;a class=&quot;ext-link&quot; href=&quot;http://www.noodleglue.org/noodleglue/javaOsg.html&quot;&gt;&lt;span class=&quot;icon&quot;&gt;JavaOSG&lt;/span&gt;&lt;/a&gt; - Java wrappers for the OpenSceneGraph (License : GNU LGPL)&lt;/p&gt;
&lt;p&gt;Bindings for theÂ  release (1.00) of all core osg libraries and Producer. Virtually all the classes and methods are accessible, and allows sub-classing of Referenced classes in Java. Includes examples using Producer's native windowing and also embedding the GL context in a Java JFrame.&lt;/p&gt;
&lt;h3 id=&quot;pyOSG&quot;&gt;pyOSG&lt;/h3&gt;
&lt;p&gt;&lt;a class=&quot;ext-link&quot; href=&quot;http://code.astraw.com/projects/pyosg/&quot;&gt;&lt;span class=&quot;icon&quot;&gt;pyOSG&lt;/span&gt;&lt;/a&gt; - Python wrappers for the OpenSceneGraph. Uses Boost Python(License : GNU LGPL)&lt;/p&gt;
&lt;h3 id=&quot;osgTcl&quot;&gt;osgTcl&lt;/h3&gt;
&lt;p&gt;A tiny Tcl wrapper based on &lt;strong&gt;osgIntrospection&lt;/strong&gt;. Download: &lt;a class=&quot;attachment&quot; href=&quot;http://www.openscenegraph.org/projects/osg/attachment/wiki/Community/LanguageWrappers/osgTcl.tar.gz&quot; title=&quot;Attachment 'osgTcl.tar.gz' in Community/LanguageWrappers&quot;&gt;osg osgTcl.tar.gz&lt;/a&gt; NB under WinXP (at least) this link downloads as osgTcl.tar.tar which errors when winzip tries to open it. Save the download file to disk, rename to osgTcl.tar.gz and winzip will open it. NB 10.03.07 the code refers to node.take - this method is equivalent to node.release. I have managed to load a model and created a SceneView object then rendering a simple scene in a Tcl3d window is easy (geoffm). Any chance of a Producer or better tk window widget?&lt;/p&gt;
&lt;h3 id=&quot;Lua&quot;&gt;Lua&lt;/h3&gt;
&lt;p&gt;Experimental prototypes of wrapping with &lt;a class=&quot;ext-link&quot; href=&quot;http://www.lua.org/&quot;&gt;&lt;span class=&quot;icon&quot;&gt;Lua&lt;/span&gt;&lt;/a&gt; are being developed under the &lt;a class=&quot;ext-link&quot; href=&quot;http://sourceforge.net/projects/osgtoy&quot;&gt;&lt;span class=&quot;icon&quot;&gt;osgToy&lt;/span&gt;&lt;/a&gt; project. (The experiment is at its barest beginnings; I just wanted to mention here as notice of activity on this front)&lt;/p&gt;
&lt;h3 id=&quot;osgLua&quot;&gt;osgLua&lt;/h3&gt;
&lt;p&gt;A full-featured and complete Lua wrapper based on osgIntrospection. osgLua checks in run-time osgIntrospection to instance any reflected class. SVN-Repository &lt;a class=&quot;ext-link&quot; href=&quot;http://svn.pplux.com/lab/osgLua&quot;&gt;&lt;span class=&quot;icon&quot;&gt;http://svn.pplux.com/lab/osgLua&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;CamlOSG&quot;&gt;CamlOSG&lt;/h3&gt;
&lt;p&gt;&lt;a class=&quot;ext-link&quot; href=&quot;http://camlosg.sourceforge.net/&quot;&gt;&lt;span class=&quot;icon&quot;&gt;CamlOSG&lt;/span&gt;&lt;/a&gt; - Objective Caml wrappers for the OpenSceneGraph (License : GNU LGPL)&lt;/p&gt;
&lt;p&gt;Bindings are done by hand (without using of osgIntrospection) and are fairly incomplete. But it is simple to add the necessary binding. Just look at the sources for example.&lt;/p&gt;</content>
		<category term="Knowledge Base" />
	</entry>
	<entry>
		<title>Matrix Transformations</title>
		<link rel="alternate" type="text/html" href="https://www.openscenegraph.com/index.php/documentation/knowledge-base/41-matrix-transformations"/>
		<published>2012-05-22T00:44:35+00:00</published>
		<updated>2012-05-22T00:44:35+00:00</updated>
		<id>https://www.openscenegraph.com/index.php/documentation/knowledge-base/41-matrix-transformations</id>
		<author>
			<name>openscenegraph</name>
			<email>jtorresfabra@gmail.com</email>
		</author>
		<summary type="html">&lt;div id=&quot;content&quot; class=&quot;wiki&quot;&gt;
&lt;div id=&quot;MatrixTransformations&quot; class=&quot;wikipage searchable&quot;&gt;If a position in space is defined by 3 coordinates (aka x,y,z) MatrixTransformations provide a method of converting the coordinate into a different coordinate frame. In OpenGL these are 4 by 4 matrices. Many references describe their use; this is a quick and dirty description.
&lt;p&gt;Example transformations:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ex 1&lt;/strong&gt;: I have a vehicle with a position in 3D space. I am looking at the vehicle from a different position, and want to draw the vehicle on a computer screen. There are 2 coordinate systems - the world (where the vehicle is) and the computer screen (x pixels, y pixels and z buffer). A matrix transform relates the world to the screen coordinate, this transformation is often thought of as a camera. Using a 4by4 matrix, the effects of perspective distortion (far things look smaller) can be modelled.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ex 2&lt;/strong&gt;: The vehicle moves through the world; the transformation of vehicle to world can also be modelled with a 4 by 4 matrix. Also the transformation of wheel rotation to vehicle coordinates uses a matrix, and the total transfrom from wheel to world to screen can be replaced by a single matrix. This is essentially what a graphics card provides. &lt;span class=&quot;wiki&quot;&gt;OpenGL&lt;/span&gt; provides a mechanism to define nested transformations such as those from the wheel to the world. Scene Graphs provide one means of defining how the transformations relate to definitions of shapes and polygons.&lt;/p&gt;
&lt;p&gt;A 4 by 4 matrix operates on a 3 coordinate by standard matrix multiplication, with an 'artifical' or homogeneous coordinate suppied as the 4th element of the coordinate (in almost all cases this coordinate is 1).&lt;/p&gt;
&lt;p&gt;&lt;tt&gt;v' = v*M&lt;/tt&gt; where v is the original position, M the matrix and v' is how the position looks on screen (or in a parent coordinate system).&lt;/p&gt;
&lt;p&gt;The matrix can be thought of as a Rotation, Scale and Translation rolled into one matrix. Then&lt;/p&gt;
&lt;p&gt;&lt;tt&gt;M = S * R * T&lt;/tt&gt;&lt;/p&gt;
&lt;p&gt;or when applied to a coordinate the coordinate is scaled, then rotated and finally translated to its destination. In the matrix the top left 3 by 3 elements represent rotation and scaling; the bottom row represents translation (and the diagonal of the rotation represents scaling).&lt;/p&gt;
&lt;p&gt;For most transformations you will use an orthonormal transformation - one where the distance between 2 points is the same before and after transforming. (The exception is the perspective transformation which is handled by 'cameras' 'cameragroups' and so on in Producer, so can generally be regarded as 'different'.)&lt;/p&gt;
&lt;p&gt;See also &lt;a class=&quot;ext-link&quot; href=&quot;http://www.makegames.com/3drotation/&quot;&gt;&lt;span class=&quot;icon&quot;&gt;http://www.makegames.com/3drotation/&lt;/span&gt;&lt;/a&gt; &lt;br /&gt; (note from Robert Osfield, the above text refers to left hand rule, and pre multiplication, whereas as &lt;span class=&quot;wiki&quot;&gt;OpenGL&lt;/span&gt; uses right hand rule, and the OSG maths classes uses post multiplication.) (GWM I think this is now corrected to right hand, post multiply.)&lt;/p&gt;
&lt;p&gt;A useful transformation is rotation or scaling about a position other than the origin. This is performed by 3 operations - move the object so that the pivot point is at the origin, rotate and move the object so that the pivot point is at its original location. This matrix is often written as&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;tt&gt;M = T' * R * T&lt;/tt&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;T' is translation by minus the pivot point T(-Xp,-Yp,-Zp), it moves the vertex v to be relative to the origin; R is rotation or scale matrix about the origin then T moves the pivot point back to its correct location T(Xp,Yp,Zp).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This matrix only needs to be calculated once (the matrix multiplies are only done once) then applied as a single matrix to all vertices below the transformation.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;by Don Burns :&lt;/p&gt;
&lt;p&gt;The OSG matrices are treated as row-major matrices, and matrix operations use prefix notation.&lt;/p&gt;
&lt;p&gt;So, in effect, this:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;tt&gt;V' = M*V;&lt;/tt&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;should not work. (For some reason, it seems that Robert has _made_ it work, which seems confusing as you are currently experiencing).&lt;/p&gt;
&lt;p&gt;It should be limited to this for consistency.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;tt&gt;V' = V * M;&lt;/tt&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So, the question is, why does OSG use this convention? The books seem to use column major, prefix notation, including the &lt;span class=&quot;wiki&quot;&gt;OpenGL&lt;/span&gt; book. However, if you read the &lt;span class=&quot;wiki&quot;&gt;OpenGL&lt;/span&gt; book then try a matrix in C you might be somewhat surprised by the result.&lt;/p&gt;
&lt;p&gt;For example, The &lt;span class=&quot;wiki&quot;&gt;OpenGL&lt;/span&gt; book says that a A rotation around Z is, (as you describe):&lt;/p&gt;
&lt;pre class=&quot;wiki&quot;&gt;    | cosA  -sinA   0    0 |
    | sinA   cosA   0    0 |
    | 0        0    1    0 |
    | 0        0    0    1 |
&lt;/pre&gt;
&lt;p&gt;However, pass this matrix&lt;/p&gt;
&lt;pre class=&quot;wiki&quot;&gt;    GLfloat ZrotateMatrix[][4] = {
       { cosA, -sinA, 0, 0 },
       { sinA,  cosA, 0, 0 },
       {    0,  0,    1, 0 },
       {    0,  0,    0, 1 }
    };

&lt;/pre&gt;
&lt;p&gt;to glLoadMatrixf(): and see what happens (g'ahead try it, don't take my word for it). Your rotations will be the opposite of what you expect.&lt;/p&gt;
&lt;p&gt;Likewise, the &lt;span class=&quot;wiki&quot;&gt;OpenGL&lt;/span&gt; book tells you that a translation matrix will look like this:&lt;/p&gt;
&lt;pre class=&quot;wiki&quot;&gt;    | 1  0  0  Tx |
    | 0  1  0  Ty |
    | 0  0  1  Tz |
    | 0  0  0  1  |

&lt;/pre&gt;
&lt;p&gt;But if you build a C matrix that looks like that, the results will be most amusing. Prove this to yourself. Write a little &lt;a class=&quot;wiki&quot; href=&quot;http://www.openscenegraph.org/projects/osg/wiki/Support/KnowledgeBase/OpenGL&quot;&gt;OpenGL&lt;/a&gt; program that translates an object along the X axis by 'X':&lt;/p&gt;
&lt;pre class=&quot;wiki&quot;&gt;// This will work:
    GLfloat mat[][4] = {
        { 1.0, 0.0, 0.0, 0.0},
        { 0.0, 1.0, 0.0, 0.0},
        { 0.0, 0.0, 1.0, 0.0},
        {   X, 0.0, 0.0, 1.0}
    };

    glPushMatrix();
    glMultMatrixf( &amp;amp;mat[0][0] );
    glutSolidTeapot( 1.0 );
    glPopMatrix();

    X += 0.01;

/// But this....

    GLfloat mat[][4] = {
        { 1.0, 0.0, 0.0, X},
        { 0.0, 1.0, 0.0, 0.0},
        { 0.0, 0.0, 1.0, 0.0},
        { 0.0, 0.0, 0.0, 1.0}
    };
&lt;/pre&gt;
&lt;p&gt;Likewise, when we are dealing with vector operations, the text books will use this notation:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;tt&gt;V' = M * V&lt;/tt&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;and in abbreviated long hand:&lt;/p&gt;
&lt;pre class=&quot;wiki&quot;&gt;    V' =  M * |Vx|
              |Vy|
              |Vz|
&lt;/pre&gt;
&lt;p&gt;Here's a challenge for you... try creating a a single column vector matrix in C or C++. :)&lt;/p&gt;
&lt;p&gt;What is familiar to us is this:&lt;/p&gt;
&lt;pre class=&quot;wiki&quot;&gt;    GLfloat vector[3] = { Vx, Vy, Vz };
&lt;/pre&gt;
&lt;p&gt;Now, the difference between OSG and OpenGL when it comes to vector/matrix operations is that OpenGL doesn't have any exposed matrix or vector math. In essence you have:&lt;/p&gt;
&lt;pre class=&quot;wiki&quot;&gt;    glLoadMatrix*()
    glMultMatrix*()
&lt;/pre&gt;
&lt;p&gt;But the implementation of these is &quot;under the covers&quot; so &lt;a class=&quot;wiki&quot; href=&quot;http://www.openscenegraph.org/projects/osg/wiki/Support/KnowledgeBase/OpenGL&quot;&gt;OpenGL&lt;/a&gt; can have the luxury of using textbook notation when discussion matrix and vector operations in the textbook. The programmer, however, will need to transpose his matrix in his mind when he is passing a C++ array to glLoadMatrix().&lt;/p&gt;
&lt;p&gt;In OSG we deliberately chose (at least I thought we did) early on to maintain a row-major, prefix notation of matrix operations to better match C++ arrays. This has implications for order of matrices and vector operations. I'm not sure what Robert intended by adding V' = M * V, but if I were you, I'd simply pretend it didn't exist so as to not confuse the issue.&lt;/p&gt;
&lt;p&gt;One more note on this issue. Order of matrix operations is a bit more &quot;comfortable&quot; (my opinion) with row-major prefix notation. Let me explain here. Say we want to make our beloved cow, sit up and beg. In the default orientation, the cow appears standing up, facing to the right (down the X axis). To make the cow sit up and beg, we'll need to first, rotate her -PI/2 around the Z axis, so she's facing us (looking down the -Y axis), then we'll need to rotate here -PI/2 around the X axis so she's sitting, head up with her hoofs extended toward us.&lt;/p&gt;
&lt;p&gt;With prefix notation, this is simply:&lt;/p&gt;
&lt;pre class=&quot;wiki&quot;&gt;    osg::Matrix A = osg::Matrix::rotate( -M_PI*0.5, 0, 0, 1 );
    osg::Matrix B = osg::Matrix::rotate( -M_PI*0.5, 1, 0, 0 );

    osg::Matrix R = A * B;
&lt;/pre&gt;
&lt;p&gt;That is, in &quot;English&quot; notation, and reading from left to right, &quot;First rotate around Z (A matrix), then rotate around X (B matrix)&quot;.&lt;/p&gt;
&lt;p&gt;However, in postfix notation, the operation would be:&lt;/p&gt;
&lt;pre class=&quot;wiki&quot;&gt;    osg::Matrix R = B * A;
&lt;/pre&gt;
&lt;p&gt;which might have a complex translation to the &quot;English&quot; notation, as it is certainly _not_ &quot;rotate around X, then rotate around Z&quot;, as this would provide us with a view of our cow after having experienced the dubious sport of cow-tipping.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Robert adds :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In OSG we deliberately chose (at least I thought we did) early on to maintain a row-major, prefix notation of matrix operations to better match C++ arrays. This has implications for order of matrices and vector operations. I'm not sure what Robert intended by adding V' = M * V, but if I were you, I'd simply pretend it didn't exist so as to not confuse the issue.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;V' = V*M and M* V are defined....&lt;/p&gt;
&lt;p&gt;the first, as Don points out is the standard one you should use, and the later is just for special occasions...&lt;/p&gt;
&lt;p&gt;And the special occasion is when you'd want to do V' = V* Mtranspose where you only have M to hand and would have to do a transpose of M.&lt;/p&gt;
&lt;p&gt;This can be rewritten V' = M * V;&lt;/p&gt;
&lt;p&gt;The particular time when you'll do this would be when transforming normals and planes by the inverse transpose. This is done all the time in the cull traversal, where the inverse just happens to be the accumulated modelview matrix.&lt;/p&gt;
&lt;p&gt;This is all a bit crafty, but certainly helps remove all those extra ops in transposing.&lt;/p&gt;
&lt;p&gt;--&lt;/p&gt;
&lt;p&gt;Gerrick Bivins provides a link to the OpenGL Transformations FAQ (&lt;a class=&quot;ext-link&quot; href=&quot;http://www.opengl.org/resources/faq/technical/transformations.htm&quot;&gt;&lt;span class=&quot;icon&quot;&gt;http://www.opengl.org/resources/faq/technical/transformations.htm&lt;/span&gt;&lt;/a&gt;) &lt;br /&gt; Usenet posts by Mark Segal and Eric Haines (&lt;a class=&quot;ext-link&quot; href=&quot;http://steve.hollasch.net/cgindex/math/matrix/column-vec.html&quot;&gt;&lt;span class=&quot;icon&quot;&gt;http://steve.hollasch.net/cgindex/math/matrix/column-vec.html&lt;/span&gt;&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</summary>
		<content type="html">&lt;div id=&quot;content&quot; class=&quot;wiki&quot;&gt;
&lt;div id=&quot;MatrixTransformations&quot; class=&quot;wikipage searchable&quot;&gt;If a position in space is defined by 3 coordinates (aka x,y,z) MatrixTransformations provide a method of converting the coordinate into a different coordinate frame. In OpenGL these are 4 by 4 matrices. Many references describe their use; this is a quick and dirty description.
&lt;p&gt;Example transformations:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ex 1&lt;/strong&gt;: I have a vehicle with a position in 3D space. I am looking at the vehicle from a different position, and want to draw the vehicle on a computer screen. There are 2 coordinate systems - the world (where the vehicle is) and the computer screen (x pixels, y pixels and z buffer). A matrix transform relates the world to the screen coordinate, this transformation is often thought of as a camera. Using a 4by4 matrix, the effects of perspective distortion (far things look smaller) can be modelled.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ex 2&lt;/strong&gt;: The vehicle moves through the world; the transformation of vehicle to world can also be modelled with a 4 by 4 matrix. Also the transformation of wheel rotation to vehicle coordinates uses a matrix, and the total transfrom from wheel to world to screen can be replaced by a single matrix. This is essentially what a graphics card provides. &lt;span class=&quot;wiki&quot;&gt;OpenGL&lt;/span&gt; provides a mechanism to define nested transformations such as those from the wheel to the world. Scene Graphs provide one means of defining how the transformations relate to definitions of shapes and polygons.&lt;/p&gt;
&lt;p&gt;A 4 by 4 matrix operates on a 3 coordinate by standard matrix multiplication, with an 'artifical' or homogeneous coordinate suppied as the 4th element of the coordinate (in almost all cases this coordinate is 1).&lt;/p&gt;
&lt;p&gt;&lt;tt&gt;v' = v*M&lt;/tt&gt; where v is the original position, M the matrix and v' is how the position looks on screen (or in a parent coordinate system).&lt;/p&gt;
&lt;p&gt;The matrix can be thought of as a Rotation, Scale and Translation rolled into one matrix. Then&lt;/p&gt;
&lt;p&gt;&lt;tt&gt;M = S * R * T&lt;/tt&gt;&lt;/p&gt;
&lt;p&gt;or when applied to a coordinate the coordinate is scaled, then rotated and finally translated to its destination. In the matrix the top left 3 by 3 elements represent rotation and scaling; the bottom row represents translation (and the diagonal of the rotation represents scaling).&lt;/p&gt;
&lt;p&gt;For most transformations you will use an orthonormal transformation - one where the distance between 2 points is the same before and after transforming. (The exception is the perspective transformation which is handled by 'cameras' 'cameragroups' and so on in Producer, so can generally be regarded as 'different'.)&lt;/p&gt;
&lt;p&gt;See also &lt;a class=&quot;ext-link&quot; href=&quot;http://www.makegames.com/3drotation/&quot;&gt;&lt;span class=&quot;icon&quot;&gt;http://www.makegames.com/3drotation/&lt;/span&gt;&lt;/a&gt; &lt;br /&gt; (note from Robert Osfield, the above text refers to left hand rule, and pre multiplication, whereas as &lt;span class=&quot;wiki&quot;&gt;OpenGL&lt;/span&gt; uses right hand rule, and the OSG maths classes uses post multiplication.) (GWM I think this is now corrected to right hand, post multiply.)&lt;/p&gt;
&lt;p&gt;A useful transformation is rotation or scaling about a position other than the origin. This is performed by 3 operations - move the object so that the pivot point is at the origin, rotate and move the object so that the pivot point is at its original location. This matrix is often written as&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;tt&gt;M = T' * R * T&lt;/tt&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;T' is translation by minus the pivot point T(-Xp,-Yp,-Zp), it moves the vertex v to be relative to the origin; R is rotation or scale matrix about the origin then T moves the pivot point back to its correct location T(Xp,Yp,Zp).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This matrix only needs to be calculated once (the matrix multiplies are only done once) then applied as a single matrix to all vertices below the transformation.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;by Don Burns :&lt;/p&gt;
&lt;p&gt;The OSG matrices are treated as row-major matrices, and matrix operations use prefix notation.&lt;/p&gt;
&lt;p&gt;So, in effect, this:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;tt&gt;V' = M*V;&lt;/tt&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;should not work. (For some reason, it seems that Robert has _made_ it work, which seems confusing as you are currently experiencing).&lt;/p&gt;
&lt;p&gt;It should be limited to this for consistency.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;tt&gt;V' = V * M;&lt;/tt&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So, the question is, why does OSG use this convention? The books seem to use column major, prefix notation, including the &lt;span class=&quot;wiki&quot;&gt;OpenGL&lt;/span&gt; book. However, if you read the &lt;span class=&quot;wiki&quot;&gt;OpenGL&lt;/span&gt; book then try a matrix in C you might be somewhat surprised by the result.&lt;/p&gt;
&lt;p&gt;For example, The &lt;span class=&quot;wiki&quot;&gt;OpenGL&lt;/span&gt; book says that a A rotation around Z is, (as you describe):&lt;/p&gt;
&lt;pre class=&quot;wiki&quot;&gt;    | cosA  -sinA   0    0 |
    | sinA   cosA   0    0 |
    | 0        0    1    0 |
    | 0        0    0    1 |
&lt;/pre&gt;
&lt;p&gt;However, pass this matrix&lt;/p&gt;
&lt;pre class=&quot;wiki&quot;&gt;    GLfloat ZrotateMatrix[][4] = {
       { cosA, -sinA, 0, 0 },
       { sinA,  cosA, 0, 0 },
       {    0,  0,    1, 0 },
       {    0,  0,    0, 1 }
    };

&lt;/pre&gt;
&lt;p&gt;to glLoadMatrixf(): and see what happens (g'ahead try it, don't take my word for it). Your rotations will be the opposite of what you expect.&lt;/p&gt;
&lt;p&gt;Likewise, the &lt;span class=&quot;wiki&quot;&gt;OpenGL&lt;/span&gt; book tells you that a translation matrix will look like this:&lt;/p&gt;
&lt;pre class=&quot;wiki&quot;&gt;    | 1  0  0  Tx |
    | 0  1  0  Ty |
    | 0  0  1  Tz |
    | 0  0  0  1  |

&lt;/pre&gt;
&lt;p&gt;But if you build a C matrix that looks like that, the results will be most amusing. Prove this to yourself. Write a little &lt;a class=&quot;wiki&quot; href=&quot;http://www.openscenegraph.org/projects/osg/wiki/Support/KnowledgeBase/OpenGL&quot;&gt;OpenGL&lt;/a&gt; program that translates an object along the X axis by 'X':&lt;/p&gt;
&lt;pre class=&quot;wiki&quot;&gt;// This will work:
    GLfloat mat[][4] = {
        { 1.0, 0.0, 0.0, 0.0},
        { 0.0, 1.0, 0.0, 0.0},
        { 0.0, 0.0, 1.0, 0.0},
        {   X, 0.0, 0.0, 1.0}
    };

    glPushMatrix();
    glMultMatrixf( &amp;amp;mat[0][0] );
    glutSolidTeapot( 1.0 );
    glPopMatrix();

    X += 0.01;

/// But this....

    GLfloat mat[][4] = {
        { 1.0, 0.0, 0.0, X},
        { 0.0, 1.0, 0.0, 0.0},
        { 0.0, 0.0, 1.0, 0.0},
        { 0.0, 0.0, 0.0, 1.0}
    };
&lt;/pre&gt;
&lt;p&gt;Likewise, when we are dealing with vector operations, the text books will use this notation:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;tt&gt;V' = M * V&lt;/tt&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;and in abbreviated long hand:&lt;/p&gt;
&lt;pre class=&quot;wiki&quot;&gt;    V' =  M * |Vx|
              |Vy|
              |Vz|
&lt;/pre&gt;
&lt;p&gt;Here's a challenge for you... try creating a a single column vector matrix in C or C++. :)&lt;/p&gt;
&lt;p&gt;What is familiar to us is this:&lt;/p&gt;
&lt;pre class=&quot;wiki&quot;&gt;    GLfloat vector[3] = { Vx, Vy, Vz };
&lt;/pre&gt;
&lt;p&gt;Now, the difference between OSG and OpenGL when it comes to vector/matrix operations is that OpenGL doesn't have any exposed matrix or vector math. In essence you have:&lt;/p&gt;
&lt;pre class=&quot;wiki&quot;&gt;    glLoadMatrix*()
    glMultMatrix*()
&lt;/pre&gt;
&lt;p&gt;But the implementation of these is &quot;under the covers&quot; so &lt;a class=&quot;wiki&quot; href=&quot;http://www.openscenegraph.org/projects/osg/wiki/Support/KnowledgeBase/OpenGL&quot;&gt;OpenGL&lt;/a&gt; can have the luxury of using textbook notation when discussion matrix and vector operations in the textbook. The programmer, however, will need to transpose his matrix in his mind when he is passing a C++ array to glLoadMatrix().&lt;/p&gt;
&lt;p&gt;In OSG we deliberately chose (at least I thought we did) early on to maintain a row-major, prefix notation of matrix operations to better match C++ arrays. This has implications for order of matrices and vector operations. I'm not sure what Robert intended by adding V' = M * V, but if I were you, I'd simply pretend it didn't exist so as to not confuse the issue.&lt;/p&gt;
&lt;p&gt;One more note on this issue. Order of matrix operations is a bit more &quot;comfortable&quot; (my opinion) with row-major prefix notation. Let me explain here. Say we want to make our beloved cow, sit up and beg. In the default orientation, the cow appears standing up, facing to the right (down the X axis). To make the cow sit up and beg, we'll need to first, rotate her -PI/2 around the Z axis, so she's facing us (looking down the -Y axis), then we'll need to rotate here -PI/2 around the X axis so she's sitting, head up with her hoofs extended toward us.&lt;/p&gt;
&lt;p&gt;With prefix notation, this is simply:&lt;/p&gt;
&lt;pre class=&quot;wiki&quot;&gt;    osg::Matrix A = osg::Matrix::rotate( -M_PI*0.5, 0, 0, 1 );
    osg::Matrix B = osg::Matrix::rotate( -M_PI*0.5, 1, 0, 0 );

    osg::Matrix R = A * B;
&lt;/pre&gt;
&lt;p&gt;That is, in &quot;English&quot; notation, and reading from left to right, &quot;First rotate around Z (A matrix), then rotate around X (B matrix)&quot;.&lt;/p&gt;
&lt;p&gt;However, in postfix notation, the operation would be:&lt;/p&gt;
&lt;pre class=&quot;wiki&quot;&gt;    osg::Matrix R = B * A;
&lt;/pre&gt;
&lt;p&gt;which might have a complex translation to the &quot;English&quot; notation, as it is certainly _not_ &quot;rotate around X, then rotate around Z&quot;, as this would provide us with a view of our cow after having experienced the dubious sport of cow-tipping.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Robert adds :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In OSG we deliberately chose (at least I thought we did) early on to maintain a row-major, prefix notation of matrix operations to better match C++ arrays. This has implications for order of matrices and vector operations. I'm not sure what Robert intended by adding V' = M * V, but if I were you, I'd simply pretend it didn't exist so as to not confuse the issue.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;V' = V*M and M* V are defined....&lt;/p&gt;
&lt;p&gt;the first, as Don points out is the standard one you should use, and the later is just for special occasions...&lt;/p&gt;
&lt;p&gt;And the special occasion is when you'd want to do V' = V* Mtranspose where you only have M to hand and would have to do a transpose of M.&lt;/p&gt;
&lt;p&gt;This can be rewritten V' = M * V;&lt;/p&gt;
&lt;p&gt;The particular time when you'll do this would be when transforming normals and planes by the inverse transpose. This is done all the time in the cull traversal, where the inverse just happens to be the accumulated modelview matrix.&lt;/p&gt;
&lt;p&gt;This is all a bit crafty, but certainly helps remove all those extra ops in transposing.&lt;/p&gt;
&lt;p&gt;--&lt;/p&gt;
&lt;p&gt;Gerrick Bivins provides a link to the OpenGL Transformations FAQ (&lt;a class=&quot;ext-link&quot; href=&quot;http://www.opengl.org/resources/faq/technical/transformations.htm&quot;&gt;&lt;span class=&quot;icon&quot;&gt;http://www.opengl.org/resources/faq/technical/transformations.htm&lt;/span&gt;&lt;/a&gt;) &lt;br /&gt; Usenet posts by Mark Segal and Eric Haines (&lt;a class=&quot;ext-link&quot; href=&quot;http://steve.hollasch.net/cgindex/math/matrix/column-vec.html&quot;&gt;&lt;span class=&quot;icon&quot;&gt;http://steve.hollasch.net/cgindex/math/matrix/column-vec.html&lt;/span&gt;&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</content>
		<category term="Knowledge Base" />
	</entry>
	<entry>
		<title>OpenGL to OpenSceneGraph Lookup</title>
		<link rel="alternate" type="text/html" href="https://www.openscenegraph.com/index.php/documentation/knowledge-base/116-opengl-to-openscenegraph-lookup"/>
		<published>2013-02-14T20:32:38+00:00</published>
		<updated>2013-02-14T20:32:38+00:00</updated>
		<id>https://www.openscenegraph.com/index.php/documentation/knowledge-base/116-opengl-to-openscenegraph-lookup</id>
		<author>
			<name>openscenegraph</name>
			<email>jtorresfabra@gmail.com</email>
		</author>
		<summary type="html">&lt;p&gt;&lt;strong&gt;Feel free to add other OpenGL calls&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Â Lookup table for helping people with converting OpenGL code to OpenSceneGraph code.&lt;/p&gt;
&lt;table class=&quot;withborder&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;OpenGL function&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&quot;wiki&quot;&gt;OpenSceneGraph&lt;/span&gt; implementation&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glClear( GLbitfield mask )&lt;/td&gt;
&lt;td&gt;osg::Camera::setClearMask(GLbitfield mask)&lt;br /&gt;osg::GraphicsContext::setClearMask(GLbitfield mask)&lt;br /&gt;osg::ClearNode::setClearMask(GLbitfield mask)&lt;br /&gt;osg::RenderStage::setClearMask(GLbitfield mask)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)&lt;/td&gt;
&lt;td&gt;osg::Camera::setClearColor(const osg::Vec4&amp;amp; color)&lt;br /&gt;osgUtil::SceneView::setClearColor(const osg::Vec4&amp;amp; color)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glClearDepth&lt;/td&gt;
&lt;td&gt;osg::Camera::setClearDepth(double depth)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glClearStencil&lt;/td&gt;
&lt;td&gt;osg::Camera::setClearStencil(int stencil)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;State Attributes&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glAlphaFunc( GLenum func, GLclampf ref )&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;AlphaFunc&lt;/span&gt;(&lt;span class=&quot;missing wiki&quot;&gt;ComparisonFunction&lt;/span&gt; func, float ref)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;BlendColor&lt;/span&gt;(const osg::Vec4&amp;amp; constantColor)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glBlendFunc( GLenum sfactor, GLenum dfactor)&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;BlendFunc&lt;/span&gt;(GLenum source, GLenum destination, GLenum source_alpha, GLenum destination_alpha)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glBlendEquation(GLenum mode)&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;BlendEquation&lt;/span&gt;(Equation equation)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glClampColor(GLenum target, GLenum mode)&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;ClampColor&lt;/span&gt;(GLenum vertexMode, GLenum fragmentMode, GLenum readMode);&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glColorMask( GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha )&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;ColorMask&lt;/span&gt;(bool red, bool green, bool blue, bool alpha);&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glMatrixMode( GL_COLOR )&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;ColorMatrix&lt;/span&gt;()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glCullFace(GLenum mode)&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;CullFace&lt;/span&gt;(Mode mode)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glDepthFunc( GLenum func)&lt;br /&gt;glDepthRange( GLclampd zNear, GLclampd zFar )&lt;br /&gt;glDepthMask( GLboolean flag )&lt;/td&gt;
&lt;td&gt;osg::Depth(Function func, double zNear, double zFar, bool writeMask)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glFog*( GLenum pname, GLfloat param )&lt;br /&gt;glFog*v(GLenum pname, const GLfloat *params )&lt;/td&gt;
&lt;td&gt;osg::Fog();&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glFogf( GL_FOG_MODE, GLfloat param )&lt;/td&gt;
&lt;td&gt;osg::Fog::setMode( Mode mode )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glFogf( GL_FOG_DENSITY, GLfloat param )&lt;/td&gt;
&lt;td&gt;osg::Fog::setDensity( float density )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glFogf( GL_FOG_START, GLfloat param )&lt;/td&gt;
&lt;td&gt;osg::Fog::setStart( float start )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glFogf( GL_FOG_END, GLfloat param )&lt;/td&gt;
&lt;td&gt;osg::Fog::setEnd( float end )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glFogf( GL_FOG_INDEX, GLfloat param )&lt;/td&gt;
&lt;td&gt;Color indexing not supported&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glFogfv(GL_FOG_COLOR, const GLfloat *params )&lt;/td&gt;
&lt;td&gt;osg::Fog::setColor( const Vec4 &amp;amp;color )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glFogi(GL_FOG_COORDINATE_SOURCE, GLenum mode)&lt;/td&gt;
&lt;td&gt;osg::Fog::setFogCoordinateSource(GLint source)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glFrontFace( GLenum mode )&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;FrontFace&lt;/span&gt;(Mode face)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glHint( GLenum target, GLenum mode )&lt;/td&gt;
&lt;td&gt;osg::Hint(GLenum target, GLenum mode)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLight*(GLenum light, GLenum pname, GLfloat param )&lt;br /&gt;glLight*v( GLenum light, GLenum pname, const GLfloat *params)&lt;/td&gt;
&lt;td&gt;osg::Light(unsigned int lightnum)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLightfv( GLenum light, GL_AMBIENT, const GLfloat *params)&lt;/td&gt;
&lt;td&gt;osg::Light::setAmbient( const Vec4&amp;amp; ambient )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLightfv( GLenum light, GL_DIFFUSE, const GLfloat *params)&lt;/td&gt;
&lt;td&gt;osg::Light::setDiffuse( const Vec4&amp;amp; diffuse )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLightfv( GLenum light, GL_SPECULAR, const GLfloat *params)&lt;/td&gt;
&lt;td&gt;osg::Light::setSpecular( const Vec4&amp;amp; specular )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLightfv( GLenum light, GL_POSITION, const GLfloat *params)&lt;/td&gt;
&lt;td&gt;osg::Light::setPosition( const Vec4&amp;amp; position )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLightfv( GLenum light, GL_SPOT_DIRECTION, const GLfloat *params)&lt;/td&gt;
&lt;td&gt;osg::Light::setDirection( const Vec3&amp;amp; direction )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLightf(GLenum light, GL_CONSTANT_ATTENUATION, GLfloat param )&lt;/td&gt;
&lt;td&gt;osg::Light::setConstantAttenuation( float constant_attenuation )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLightf(GLenum light, GL_LINEAR_ATTENUATION, GLfloat param )&lt;/td&gt;
&lt;td&gt;osg::Light::setLinearAttenuation ( float linear_attenuation )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLightf(GLenum light, GL_QUADRATIC_ATTENUATION, GLfloat param )&lt;/td&gt;
&lt;td&gt;osg::Light::setQuadraticAttenuation ( float quadratic_attenuation )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLightf(GLenum light, GL_SPOT_EXPONENT, GLfloat param )&lt;/td&gt;
&lt;td&gt;osg::Light::setSpotExponent( float spot_exponent )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLightf(GLenum light, GL_SPOT_CUTOFF, GLfloat param )&lt;/td&gt;
&lt;td&gt;osg::Light::setSpotCutoff( float spot_cutoff )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLightModel*( GLenum pname, GLfloat param )&lt;br /&gt;glLightModel*v( GLenum pname, const GLfloat *params )&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;LightModel&lt;/span&gt;()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLightModelfv( GL_LIGHT_MODEL_AMBIENT, const GLfloat *params )&lt;/td&gt;
&lt;td&gt;osg::LightModel::setAmbientIntensity(const osg::Vec4&amp;amp; ambient)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLightModeli(GL_LIGHT_MODEL_COLOR_CONTROL, GLint param)&lt;/td&gt;
&lt;td&gt;osg::LightModel::setColorControl(&lt;span class=&quot;missing wiki&quot;&gt;ColorControl&lt;/span&gt; cc)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLightModeli( GL_LIGHT_MODEL_LOCAL_VIEWER, GLint param )&lt;/td&gt;
&lt;td&gt;osg::LightModel::setLocalViewer(bool localViewer)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLightModeli( GL_LIGHT_MODEL_TWO_SIDE, GLint param )&lt;/td&gt;
&lt;td&gt;osg::LightModel::setTwoSided(bool twoSided)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLineStipple( GLint factor, GLushort pattern )&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;LineStipple&lt;/span&gt;(GLint factor, GLushort pattern)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLineWidth( GLfloat width )&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;LineWidth&lt;/span&gt;(float width=1.0f)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLogicOp( GLenum opcode )&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;LogicOp&lt;/span&gt;(Opcode opcode)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glMaterialf(GLenum face, GLenum pname, GLfloat param )&lt;/td&gt;
&lt;td&gt;osg::Material()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Â &lt;/td&gt;
&lt;td&gt;osg::Multisample()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Â &lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;PolygonMode&lt;/span&gt;(Face face,Mode mode)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Â &lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;PolygonOffset&lt;/span&gt;(float factor, float units)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Â &lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;PolygonStipple&lt;/span&gt;(const GLubyte* mask)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Â &lt;/td&gt;
&lt;td&gt;osg::Scissor(int x,int y,int width,int height)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Â &lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;ShadeModel&lt;/span&gt;(Mode mode)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glStencilFunc( GLenum func, GLint ref, GLuint mask )&lt;/td&gt;
&lt;td&gt;osg::Stencil::setFunction(Function func,int ref,unsigned int mask)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glStencilMask( GLuint mask )&lt;/td&gt;
&lt;td&gt;osg::Stencil::setOperation(Operation sfail, Operation zfail, Operation zpass)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glStencilOp( GLenum fail, GLenum zfail, GLenum zpass )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Â &lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;StencilTwoSided&lt;/span&gt;()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, ...)&lt;br /&gt;glTexEnvfv( GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, ...)&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;TexEnv&lt;/span&gt;(Mode mode)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glTexEnvi( GL_TEXTURE_ENV, ...)&lt;br /&gt;Texture combiners extension&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;TexEnvCombine&lt;/span&gt;()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glTexEnvf(GL_TEXTURE_FILTER_CONTROL_EXT, GL_TEXTURE_LOD_BIAS_EXT, ...)&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;TexEnvFilter&lt;/span&gt;(float lodBias)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glTexGen_( GLenum coord, GLenum pname, GLdouble param )&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;TexGen&lt;/span&gt;()&lt;br /&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;TexGenNode&lt;/span&gt;()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glMatrixMode( GL_TEXTURE )&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;TexMat&lt;/span&gt;(const Matrix&amp;amp; matrix)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glTexImage1D( GL_TEXTURE_1D, ...)&lt;/td&gt;
&lt;td&gt;osg::Texture1D()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glTexImage2D( GL_TEXTURE_2D, ...)&lt;/td&gt;
&lt;td&gt;osg::Texture2D(Image* image)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glTexImage3D( GL_TEXTURE_2D_ARRAY_EXT, ...)&lt;/td&gt;
&lt;td&gt;osg::Texture2DArray()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glTexImage3D( GL_TEXTURE_3D, ...)&lt;/td&gt;
&lt;td&gt;osg::Texture3D()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glTexImage2D( GL_TEXTURE_CUBE_MAP_POSITIVE_X, ...)&lt;br /&gt;glTexImage2D( GL_TEXTURE_CUBE_MAP_NEGATIVE_X, ...)&lt;br /&gt;glTexImage2D( GL_TEXTURE_CUBE_MAP_POSITIVE_Y, ...)&lt;br /&gt;glTexImage2D( GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, ...)&lt;br /&gt;glTexImage2D( GL_TEXTURE_CUBE_MAP_POSITIVE_Z, ...)&lt;br /&gt;glTexImage2D( GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, ...)&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;TextureCubeMap&lt;/span&gt;()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glTexImage2D( GL_TEXTURE_RECTANGLE, ...)&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;TextureRectangle&lt;/span&gt;(Image* image)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glViewport( GLint x, GLint y, GLsizei width, GLsizei height )&lt;/td&gt;
&lt;td&gt;osg::Viewport(value_type x,value_type y,value_type width,value_type height)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</summary>
		<content type="html">&lt;p&gt;&lt;strong&gt;Feel free to add other OpenGL calls&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Â Lookup table for helping people with converting OpenGL code to OpenSceneGraph code.&lt;/p&gt;
&lt;table class=&quot;withborder&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;OpenGL function&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&quot;wiki&quot;&gt;OpenSceneGraph&lt;/span&gt; implementation&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glClear( GLbitfield mask )&lt;/td&gt;
&lt;td&gt;osg::Camera::setClearMask(GLbitfield mask)&lt;br /&gt;osg::GraphicsContext::setClearMask(GLbitfield mask)&lt;br /&gt;osg::ClearNode::setClearMask(GLbitfield mask)&lt;br /&gt;osg::RenderStage::setClearMask(GLbitfield mask)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)&lt;/td&gt;
&lt;td&gt;osg::Camera::setClearColor(const osg::Vec4&amp;amp; color)&lt;br /&gt;osgUtil::SceneView::setClearColor(const osg::Vec4&amp;amp; color)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glClearDepth&lt;/td&gt;
&lt;td&gt;osg::Camera::setClearDepth(double depth)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glClearStencil&lt;/td&gt;
&lt;td&gt;osg::Camera::setClearStencil(int stencil)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;State Attributes&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glAlphaFunc( GLenum func, GLclampf ref )&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;AlphaFunc&lt;/span&gt;(&lt;span class=&quot;missing wiki&quot;&gt;ComparisonFunction&lt;/span&gt; func, float ref)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;BlendColor&lt;/span&gt;(const osg::Vec4&amp;amp; constantColor)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glBlendFunc( GLenum sfactor, GLenum dfactor)&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;BlendFunc&lt;/span&gt;(GLenum source, GLenum destination, GLenum source_alpha, GLenum destination_alpha)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glBlendEquation(GLenum mode)&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;BlendEquation&lt;/span&gt;(Equation equation)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glClampColor(GLenum target, GLenum mode)&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;ClampColor&lt;/span&gt;(GLenum vertexMode, GLenum fragmentMode, GLenum readMode);&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glColorMask( GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha )&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;ColorMask&lt;/span&gt;(bool red, bool green, bool blue, bool alpha);&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glMatrixMode( GL_COLOR )&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;ColorMatrix&lt;/span&gt;()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glCullFace(GLenum mode)&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;CullFace&lt;/span&gt;(Mode mode)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glDepthFunc( GLenum func)&lt;br /&gt;glDepthRange( GLclampd zNear, GLclampd zFar )&lt;br /&gt;glDepthMask( GLboolean flag )&lt;/td&gt;
&lt;td&gt;osg::Depth(Function func, double zNear, double zFar, bool writeMask)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glFog*( GLenum pname, GLfloat param )&lt;br /&gt;glFog*v(GLenum pname, const GLfloat *params )&lt;/td&gt;
&lt;td&gt;osg::Fog();&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glFogf( GL_FOG_MODE, GLfloat param )&lt;/td&gt;
&lt;td&gt;osg::Fog::setMode( Mode mode )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glFogf( GL_FOG_DENSITY, GLfloat param )&lt;/td&gt;
&lt;td&gt;osg::Fog::setDensity( float density )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glFogf( GL_FOG_START, GLfloat param )&lt;/td&gt;
&lt;td&gt;osg::Fog::setStart( float start )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glFogf( GL_FOG_END, GLfloat param )&lt;/td&gt;
&lt;td&gt;osg::Fog::setEnd( float end )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glFogf( GL_FOG_INDEX, GLfloat param )&lt;/td&gt;
&lt;td&gt;Color indexing not supported&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glFogfv(GL_FOG_COLOR, const GLfloat *params )&lt;/td&gt;
&lt;td&gt;osg::Fog::setColor( const Vec4 &amp;amp;color )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glFogi(GL_FOG_COORDINATE_SOURCE, GLenum mode)&lt;/td&gt;
&lt;td&gt;osg::Fog::setFogCoordinateSource(GLint source)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glFrontFace( GLenum mode )&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;FrontFace&lt;/span&gt;(Mode face)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glHint( GLenum target, GLenum mode )&lt;/td&gt;
&lt;td&gt;osg::Hint(GLenum target, GLenum mode)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLight*(GLenum light, GLenum pname, GLfloat param )&lt;br /&gt;glLight*v( GLenum light, GLenum pname, const GLfloat *params)&lt;/td&gt;
&lt;td&gt;osg::Light(unsigned int lightnum)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLightfv( GLenum light, GL_AMBIENT, const GLfloat *params)&lt;/td&gt;
&lt;td&gt;osg::Light::setAmbient( const Vec4&amp;amp; ambient )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLightfv( GLenum light, GL_DIFFUSE, const GLfloat *params)&lt;/td&gt;
&lt;td&gt;osg::Light::setDiffuse( const Vec4&amp;amp; diffuse )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLightfv( GLenum light, GL_SPECULAR, const GLfloat *params)&lt;/td&gt;
&lt;td&gt;osg::Light::setSpecular( const Vec4&amp;amp; specular )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLightfv( GLenum light, GL_POSITION, const GLfloat *params)&lt;/td&gt;
&lt;td&gt;osg::Light::setPosition( const Vec4&amp;amp; position )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLightfv( GLenum light, GL_SPOT_DIRECTION, const GLfloat *params)&lt;/td&gt;
&lt;td&gt;osg::Light::setDirection( const Vec3&amp;amp; direction )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLightf(GLenum light, GL_CONSTANT_ATTENUATION, GLfloat param )&lt;/td&gt;
&lt;td&gt;osg::Light::setConstantAttenuation( float constant_attenuation )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLightf(GLenum light, GL_LINEAR_ATTENUATION, GLfloat param )&lt;/td&gt;
&lt;td&gt;osg::Light::setLinearAttenuation ( float linear_attenuation )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLightf(GLenum light, GL_QUADRATIC_ATTENUATION, GLfloat param )&lt;/td&gt;
&lt;td&gt;osg::Light::setQuadraticAttenuation ( float quadratic_attenuation )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLightf(GLenum light, GL_SPOT_EXPONENT, GLfloat param )&lt;/td&gt;
&lt;td&gt;osg::Light::setSpotExponent( float spot_exponent )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLightf(GLenum light, GL_SPOT_CUTOFF, GLfloat param )&lt;/td&gt;
&lt;td&gt;osg::Light::setSpotCutoff( float spot_cutoff )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLightModel*( GLenum pname, GLfloat param )&lt;br /&gt;glLightModel*v( GLenum pname, const GLfloat *params )&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;LightModel&lt;/span&gt;()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLightModelfv( GL_LIGHT_MODEL_AMBIENT, const GLfloat *params )&lt;/td&gt;
&lt;td&gt;osg::LightModel::setAmbientIntensity(const osg::Vec4&amp;amp; ambient)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLightModeli(GL_LIGHT_MODEL_COLOR_CONTROL, GLint param)&lt;/td&gt;
&lt;td&gt;osg::LightModel::setColorControl(&lt;span class=&quot;missing wiki&quot;&gt;ColorControl&lt;/span&gt; cc)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLightModeli( GL_LIGHT_MODEL_LOCAL_VIEWER, GLint param )&lt;/td&gt;
&lt;td&gt;osg::LightModel::setLocalViewer(bool localViewer)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLightModeli( GL_LIGHT_MODEL_TWO_SIDE, GLint param )&lt;/td&gt;
&lt;td&gt;osg::LightModel::setTwoSided(bool twoSided)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLineStipple( GLint factor, GLushort pattern )&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;LineStipple&lt;/span&gt;(GLint factor, GLushort pattern)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLineWidth( GLfloat width )&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;LineWidth&lt;/span&gt;(float width=1.0f)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glLogicOp( GLenum opcode )&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;LogicOp&lt;/span&gt;(Opcode opcode)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glMaterialf(GLenum face, GLenum pname, GLfloat param )&lt;/td&gt;
&lt;td&gt;osg::Material()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Â &lt;/td&gt;
&lt;td&gt;osg::Multisample()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Â &lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;PolygonMode&lt;/span&gt;(Face face,Mode mode)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Â &lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;PolygonOffset&lt;/span&gt;(float factor, float units)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Â &lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;PolygonStipple&lt;/span&gt;(const GLubyte* mask)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Â &lt;/td&gt;
&lt;td&gt;osg::Scissor(int x,int y,int width,int height)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Â &lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;ShadeModel&lt;/span&gt;(Mode mode)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glStencilFunc( GLenum func, GLint ref, GLuint mask )&lt;/td&gt;
&lt;td&gt;osg::Stencil::setFunction(Function func,int ref,unsigned int mask)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glStencilMask( GLuint mask )&lt;/td&gt;
&lt;td&gt;osg::Stencil::setOperation(Operation sfail, Operation zfail, Operation zpass)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glStencilOp( GLenum fail, GLenum zfail, GLenum zpass )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Â &lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;StencilTwoSided&lt;/span&gt;()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, ...)&lt;br /&gt;glTexEnvfv( GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, ...)&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;TexEnv&lt;/span&gt;(Mode mode)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glTexEnvi( GL_TEXTURE_ENV, ...)&lt;br /&gt;Texture combiners extension&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;TexEnvCombine&lt;/span&gt;()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glTexEnvf(GL_TEXTURE_FILTER_CONTROL_EXT, GL_TEXTURE_LOD_BIAS_EXT, ...)&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;TexEnvFilter&lt;/span&gt;(float lodBias)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glTexGen_( GLenum coord, GLenum pname, GLdouble param )&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;TexGen&lt;/span&gt;()&lt;br /&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;TexGenNode&lt;/span&gt;()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glMatrixMode( GL_TEXTURE )&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;TexMat&lt;/span&gt;(const Matrix&amp;amp; matrix)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glTexImage1D( GL_TEXTURE_1D, ...)&lt;/td&gt;
&lt;td&gt;osg::Texture1D()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glTexImage2D( GL_TEXTURE_2D, ...)&lt;/td&gt;
&lt;td&gt;osg::Texture2D(Image* image)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glTexImage3D( GL_TEXTURE_2D_ARRAY_EXT, ...)&lt;/td&gt;
&lt;td&gt;osg::Texture2DArray()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glTexImage3D( GL_TEXTURE_3D, ...)&lt;/td&gt;
&lt;td&gt;osg::Texture3D()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glTexImage2D( GL_TEXTURE_CUBE_MAP_POSITIVE_X, ...)&lt;br /&gt;glTexImage2D( GL_TEXTURE_CUBE_MAP_NEGATIVE_X, ...)&lt;br /&gt;glTexImage2D( GL_TEXTURE_CUBE_MAP_POSITIVE_Y, ...)&lt;br /&gt;glTexImage2D( GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, ...)&lt;br /&gt;glTexImage2D( GL_TEXTURE_CUBE_MAP_POSITIVE_Z, ...)&lt;br /&gt;glTexImage2D( GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, ...)&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;TextureCubeMap&lt;/span&gt;()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glTexImage2D( GL_TEXTURE_RECTANGLE, ...)&lt;/td&gt;
&lt;td&gt;osg::&lt;span class=&quot;missing wiki&quot;&gt;TextureRectangle&lt;/span&gt;(Image* image)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;glViewport( GLint x, GLint y, GLsizei width, GLsizei height )&lt;/td&gt;
&lt;td&gt;osg::Viewport(value_type x,value_type y,value_type width,value_type height)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content>
		<category term="Knowledge Base" />
	</entry>
	<entry>
		<title>Perspective Transformation</title>
		<link rel="alternate" type="text/html" href="https://www.openscenegraph.com/index.php/documentation/knowledge-base/75-perspective-transformation"/>
		<published>2012-10-16T23:50:20+00:00</published>
		<updated>2012-10-16T23:50:20+00:00</updated>
		<id>https://www.openscenegraph.com/index.php/documentation/knowledge-base/75-perspective-transformation</id>
		<author>
			<name>openscenegraph</name>
			<email>jtorresfabra@gmail.com</email>
		</author>
		<summary type="html">&lt;p&gt;Perspective Transformation is performed by a 4 by 4 matrix with elements in the final column:&lt;/p&gt;
&lt;pre class=&quot;wiki&quot;&gt; Mpersp =  1        0       0       0
        =  0        1       0       0
        =  0        0       1       1/d
        =  0        0       0       0
&lt;/pre&gt;
&lt;p&gt;then [xyz1].Mpersp = [x,y,z,z/d] and as the w coordinate is effectively a scaling factor, items which are further away from the eye are 'shrunk' on the screen pixels. The red book gives a full description of the viewing transforms.&lt;/p&gt;</summary>
		<content type="html">&lt;p&gt;Perspective Transformation is performed by a 4 by 4 matrix with elements in the final column:&lt;/p&gt;
&lt;pre class=&quot;wiki&quot;&gt; Mpersp =  1        0       0       0
        =  0        1       0       0
        =  0        0       1       1/d
        =  0        0       0       0
&lt;/pre&gt;
&lt;p&gt;then [xyz1].Mpersp = [x,y,z,z/d] and as the w coordinate is effectively a scaling factor, items which are further away from the eye are 'shrunk' on the screen pixels. The red book gives a full description of the viewing transforms.&lt;/p&gt;</content>
		<category term="Knowledge Base" />
	</entry>
	<entry>
		<title>Quaternion Maths</title>
		<link rel="alternate" type="text/html" href="https://www.openscenegraph.com/index.php/documentation/knowledge-base/40-quaternion-maths"/>
		<published>2012-05-22T00:18:54+00:00</published>
		<updated>2012-05-22T00:18:54+00:00</updated>
		<id>https://www.openscenegraph.com/index.php/documentation/knowledge-base/40-quaternion-maths</id>
		<author>
			<name>openscenegraph</name>
			<email>jtorresfabra@gmail.com</email>
		</author>
		<summary type="html">&lt;p&gt;Quaternions describe rotation transformations (at least as far as a &lt;a href=&quot;https://www.openscenegraph.com/index.php/documentation/knowledge-base/36-what-is-a-scene-graph&quot;&gt;SceneGraph&lt;/a&gt; is concerned).&lt;/p&gt;
&lt;p&gt;A quaternion (invented by W R Hamilton &lt;a class=&quot;ext-link&quot; href=&quot;http://mathworld.wolfram.com/Quaternion.html&quot;&gt;&lt;span class=&quot;icon&quot;&gt;http://mathworld.wolfram.com/Quaternion.html&lt;/span&gt;&lt;/a&gt;) is a number system like complex numbers but with 3 imaginary values and one real. The real term can be thought of as a rotation angle (actually COS(angle/2)) and the imaginary terms as a direction vector, the quaternion is a rotation about the vector. The imaginary terms are commonly written as [i,j,k] (a notation which has remained in use in vector notations). the products of ijk are: i*i=j*j=k*k=-1 and i*j*k=-1 too. Hence j*k = i, i*j=k and k*i=j - the order of multiplication is important, and the products can be considered as the cross product of the vectors, hence their usefulness in rotating frames where gyroscopic precession obeys similar cross product laws.&lt;/p&gt;
&lt;p&gt;It is not obvious that any possible orientation of one coordinate system to another can be represented by a Quaternion, but it is so. {For hand waving purposes, there are 3 axes of space, so 3 parameters are required - such as EulerAngles - and the unit quaternion has 3 independent parameters so that is just enough adjustables). The length preserving unitary transformations required by most applications of a &lt;a href=&quot;https://www.openscenegraph.com/index.php/documentation/knowledge-base/36-what-is-a-scene-graph&quot;&gt;SceneGraph&lt;/a&gt; are unit quaternions - that is the sum of squares of the 4 components add up to 1.&lt;/p&gt;
&lt;p&gt;The OpenSceneGraph provides many utilities to convert Quaternions to Matrices. Quaternions do not suffer from local infinities when a scene is being rotated, unlike an EulerAngle. For example imagine flying an aeroplane due North and pull back the stick until you are nearly flying vertically - you are still flying North, just slowly. Continue pulling back the stick and suddenly (instantly) you are flying South, the EulerAngle for heading has reversed. The quaternion representation of your flight changes smoothly through any orientation change. Quaternions are preferred when integrating up velocity &amp;amp; rotation rate to find a new position.&lt;/p&gt;
&lt;p&gt;I have just returned from Dublin where I saw the bridge where WR Hamilton scratched his equation (not that this is important to the maths). When implemented as a quaternion, the rotation matrix about X for an angle A is&lt;/p&gt;
&lt;pre class=&quot;wiki&quot;&gt;q = [cos(A/2), sin(A/2), 0, 0] {written as qw,qx,qy,qz}
&lt;/pre&gt;
&lt;p&gt;The euler angles are [A,0,0] BUT the matrices are:&lt;/p&gt;
&lt;p&gt;(Quaternion form):&lt;/p&gt;
&lt;pre class=&quot;wiki&quot;&gt; 1       0        0       0
 0 (1-2*qx^2)  - 2*qx*qw  0
 0   2*qx*qw  (1-2*qx^2)  0
 0       0        0       1
&lt;/pre&gt;
&lt;p&gt;and in Euler form:&lt;/p&gt;
&lt;pre class=&quot;wiki&quot;&gt; 1       0        0       0
 0    cos(A)   -sin(A)    0
 0      sin(A)  cos(A)    0
 0       0        0       1
&lt;/pre&gt;
&lt;p&gt;Strangely(!) the same result of course, but the Euler form requires evaluating cos and sin 4 times, quaternion at most twice (if you have been integrating the velocity and rotation rate then the quaternion requires NO sin and cos evaluations). This make quaternions much more numerically efficient. Obviously care is needed to be sure that the quaternion axes are consistent with the rotation axes, but we wouldn't be here otherwise.(GWM)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Fast normalisation of quaternions&lt;/strong&gt;. If the quaternion deviates from a unit length then it represents a distortion of space (generally undesirable in Visual Simulation). If a quaternion is being integrated to get the orientation of a vehicle, then rounding errors are likely to make the quaternion slightly longer or shorter than unit. You can normalise in a 'brute force' manner by dividing by square root of length - but square roots are relatively slow, and the error should be very small. So write the square of the actual length as:&lt;/p&gt;
&lt;pre class=&quot;wiki&quot;&gt; qw^2 + qx^2 + qy^2 + qz^2 = 1+alpha
&lt;/pre&gt;
&lt;p&gt;then normalising the quaternion requires (qw,qx,qy,qz) to be divided by sqrt(1+alpha). Assuming alpha is small, this is equivalent to multiplying by (1-0.5*alpha)- since no square root is involved the correction can be made very efficiently. (GWM).&lt;/p&gt;</summary>
		<content type="html">&lt;p&gt;Quaternions describe rotation transformations (at least as far as a &lt;a href=&quot;https://www.openscenegraph.com/index.php/documentation/knowledge-base/36-what-is-a-scene-graph&quot;&gt;SceneGraph&lt;/a&gt; is concerned).&lt;/p&gt;
&lt;p&gt;A quaternion (invented by W R Hamilton &lt;a class=&quot;ext-link&quot; href=&quot;http://mathworld.wolfram.com/Quaternion.html&quot;&gt;&lt;span class=&quot;icon&quot;&gt;http://mathworld.wolfram.com/Quaternion.html&lt;/span&gt;&lt;/a&gt;) is a number system like complex numbers but with 3 imaginary values and one real. The real term can be thought of as a rotation angle (actually COS(angle/2)) and the imaginary terms as a direction vector, the quaternion is a rotation about the vector. The imaginary terms are commonly written as [i,j,k] (a notation which has remained in use in vector notations). the products of ijk are: i*i=j*j=k*k=-1 and i*j*k=-1 too. Hence j*k = i, i*j=k and k*i=j - the order of multiplication is important, and the products can be considered as the cross product of the vectors, hence their usefulness in rotating frames where gyroscopic precession obeys similar cross product laws.&lt;/p&gt;
&lt;p&gt;It is not obvious that any possible orientation of one coordinate system to another can be represented by a Quaternion, but it is so. {For hand waving purposes, there are 3 axes of space, so 3 parameters are required - such as EulerAngles - and the unit quaternion has 3 independent parameters so that is just enough adjustables). The length preserving unitary transformations required by most applications of a &lt;a href=&quot;https://www.openscenegraph.com/index.php/documentation/knowledge-base/36-what-is-a-scene-graph&quot;&gt;SceneGraph&lt;/a&gt; are unit quaternions - that is the sum of squares of the 4 components add up to 1.&lt;/p&gt;
&lt;p&gt;The OpenSceneGraph provides many utilities to convert Quaternions to Matrices. Quaternions do not suffer from local infinities when a scene is being rotated, unlike an EulerAngle. For example imagine flying an aeroplane due North and pull back the stick until you are nearly flying vertically - you are still flying North, just slowly. Continue pulling back the stick and suddenly (instantly) you are flying South, the EulerAngle for heading has reversed. The quaternion representation of your flight changes smoothly through any orientation change. Quaternions are preferred when integrating up velocity &amp;amp; rotation rate to find a new position.&lt;/p&gt;
&lt;p&gt;I have just returned from Dublin where I saw the bridge where WR Hamilton scratched his equation (not that this is important to the maths). When implemented as a quaternion, the rotation matrix about X for an angle A is&lt;/p&gt;
&lt;pre class=&quot;wiki&quot;&gt;q = [cos(A/2), sin(A/2), 0, 0] {written as qw,qx,qy,qz}
&lt;/pre&gt;
&lt;p&gt;The euler angles are [A,0,0] BUT the matrices are:&lt;/p&gt;
&lt;p&gt;(Quaternion form):&lt;/p&gt;
&lt;pre class=&quot;wiki&quot;&gt; 1       0        0       0
 0 (1-2*qx^2)  - 2*qx*qw  0
 0   2*qx*qw  (1-2*qx^2)  0
 0       0        0       1
&lt;/pre&gt;
&lt;p&gt;and in Euler form:&lt;/p&gt;
&lt;pre class=&quot;wiki&quot;&gt; 1       0        0       0
 0    cos(A)   -sin(A)    0
 0      sin(A)  cos(A)    0
 0       0        0       1
&lt;/pre&gt;
&lt;p&gt;Strangely(!) the same result of course, but the Euler form requires evaluating cos and sin 4 times, quaternion at most twice (if you have been integrating the velocity and rotation rate then the quaternion requires NO sin and cos evaluations). This make quaternions much more numerically efficient. Obviously care is needed to be sure that the quaternion axes are consistent with the rotation axes, but we wouldn't be here otherwise.(GWM)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Fast normalisation of quaternions&lt;/strong&gt;. If the quaternion deviates from a unit length then it represents a distortion of space (generally undesirable in Visual Simulation). If a quaternion is being integrated to get the orientation of a vehicle, then rounding errors are likely to make the quaternion slightly longer or shorter than unit. You can normalise in a 'brute force' manner by dividing by square root of length - but square roots are relatively slow, and the error should be very small. So write the square of the actual length as:&lt;/p&gt;
&lt;pre class=&quot;wiki&quot;&gt; qw^2 + qx^2 + qy^2 + qz^2 = 1+alpha
&lt;/pre&gt;
&lt;p&gt;then normalising the quaternion requires (qw,qx,qy,qz) to be divided by sqrt(1+alpha). Assuming alpha is small, this is equivalent to multiplying by (1-0.5*alpha)- since no square root is involved the correction can be made very efficiently. (GWM).&lt;/p&gt;</content>
		<category term="Knowledge Base" />
	</entry>
	<entry>
		<title>Use the Source Luke!</title>
		<link rel="alternate" type="text/html" href="https://www.openscenegraph.com/index.php/documentation/knowledge-base/65-use-the-source-luke"/>
		<published>2012-09-19T00:32:07+00:00</published>
		<updated>2012-09-19T00:32:07+00:00</updated>
		<id>https://www.openscenegraph.com/index.php/documentation/knowledge-base/65-use-the-source-luke</id>
		<author>
			<name>openscenegraph</name>
			<email>jtorresfabra@gmail.com</email>
		</author>
		<summary type="html">&lt;p&gt;The best way to find out what the code does is&lt;strong&gt; to look at the source&lt;/strong&gt;. That's the only thing that never fails. Documentation gets out of sync, comments lie, and colleagues forget, but The Source is eternal.&lt;/p&gt;
&lt;p&gt;Actually, the best way to find out what the code does is to watch it doing it inside a debugger. See the &lt;a href=&quot;https://www.openscenegraph.com/index.php/documentation/debugging-tips&quot;&gt;debugging tips&lt;/a&gt; for more information.&lt;/p&gt;
&lt;p&gt;True... if your code isn't time sensitive... and your debugger (or monitoring system) is perfect. Debuggers can tell you very little about complex software, and often lead you to looking in the wrong place anyways. Especially in languages with poor debugger support, like c/c++, this can lead to a horrible style of band-aid debugging that uniformly decreases the maintainability of the software.&lt;/p&gt;
&lt;p&gt;The scenario goes something like this. A (rushed/confused/incompetent) coder is staring at the symptom in the debugger, say an array overrun in c code. The software as a whole lacks the analytical framework (test suite, invariant analysis, etc.) to help discover the *root* cause of this problem, and after minutes-&amp;gt;hours of messing about in the debugger, the coder still doesn't really understand what is going on. However, he sees a local fix, and patches in some test that keeps the overrun from occurring and smashing the stack. Result? The code no longer fails.&lt;/p&gt;
&lt;p&gt;Great, right? Fundamentally misguided is more like it. The failure mode still exists, and is silently corrected local to where the problem showed up. What is likely to happen is that a further change in the code later one will re-expose the problem in a different way. But now some (perhaps unrelated) function has this hacked in logic (perhaps un- or poorly documented) which no longer really applies and didn't really make sense in the first place. Propagate this sort of 'fix' through an Mloc system over a few years and what you end up with is a travesty.&lt;/p&gt;
&lt;p&gt;The best way to find out what the code does is&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;a)&lt;/strong&gt; understand what it is trying to do&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;b)&lt;/strong&gt; understand what the implementation *should* do&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;c)&lt;/strong&gt; test this understanding (with test code (do you have several years to waste stepping through code?))&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.... n)&lt;/strong&gt; as a last resort, if nothing is making sense, fire up the debugger *on the right piece of code* (which you can only describe if you actually understand what is going on) and see what you have misunderstood.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;n+1)&lt;/strong&gt; see if the compiler is lying to you ...&lt;/p&gt;
&lt;/blockquote&gt;</summary>
		<content type="html">&lt;p&gt;The best way to find out what the code does is&lt;strong&gt; to look at the source&lt;/strong&gt;. That's the only thing that never fails. Documentation gets out of sync, comments lie, and colleagues forget, but The Source is eternal.&lt;/p&gt;
&lt;p&gt;Actually, the best way to find out what the code does is to watch it doing it inside a debugger. See the &lt;a href=&quot;https://www.openscenegraph.com/index.php/documentation/debugging-tips&quot;&gt;debugging tips&lt;/a&gt; for more information.&lt;/p&gt;
&lt;p&gt;True... if your code isn't time sensitive... and your debugger (or monitoring system) is perfect. Debuggers can tell you very little about complex software, and often lead you to looking in the wrong place anyways. Especially in languages with poor debugger support, like c/c++, this can lead to a horrible style of band-aid debugging that uniformly decreases the maintainability of the software.&lt;/p&gt;
&lt;p&gt;The scenario goes something like this. A (rushed/confused/incompetent) coder is staring at the symptom in the debugger, say an array overrun in c code. The software as a whole lacks the analytical framework (test suite, invariant analysis, etc.) to help discover the *root* cause of this problem, and after minutes-&amp;gt;hours of messing about in the debugger, the coder still doesn't really understand what is going on. However, he sees a local fix, and patches in some test that keeps the overrun from occurring and smashing the stack. Result? The code no longer fails.&lt;/p&gt;
&lt;p&gt;Great, right? Fundamentally misguided is more like it. The failure mode still exists, and is silently corrected local to where the problem showed up. What is likely to happen is that a further change in the code later one will re-expose the problem in a different way. But now some (perhaps unrelated) function has this hacked in logic (perhaps un- or poorly documented) which no longer really applies and didn't really make sense in the first place. Propagate this sort of 'fix' through an Mloc system over a few years and what you end up with is a travesty.&lt;/p&gt;
&lt;p&gt;The best way to find out what the code does is&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;a)&lt;/strong&gt; understand what it is trying to do&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;b)&lt;/strong&gt; understand what the implementation *should* do&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;c)&lt;/strong&gt; test this understanding (with test code (do you have several years to waste stepping through code?))&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.... n)&lt;/strong&gt; as a last resort, if nothing is making sense, fire up the debugger *on the right piece of code* (which you can only describe if you actually understand what is going on) and see what you have misunderstood.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;n+1)&lt;/strong&gt; see if the compiler is lying to you ...&lt;/p&gt;
&lt;/blockquote&gt;</content>
		<category term="Knowledge Base" />
	</entry>
	<entry>
		<title>Views and Viewers</title>
		<link rel="alternate" type="text/html" href="https://www.openscenegraph.com/index.php/documentation/knowledge-base/92-views-and-viewers"/>
		<published>2013-01-19T03:10:15+00:00</published>
		<updated>2013-01-19T03:10:15+00:00</updated>
		<id>https://www.openscenegraph.com/index.php/documentation/knowledge-base/92-views-and-viewers</id>
		<author>
			<name>openscenegraph</name>
			<email>jtorresfabra@gmail.com</email>
		</author>
		<summary type="html">&lt;h3 id=&quot;BasicDescription&quot;&gt;Basic Description&lt;/h3&gt;
&lt;p&gt;There is a &lt;a href=&quot;http://www.openscenegraph.org/projects/osg/wiki/Community/Tasks/osgViewer&quot;&gt;history&lt;/a&gt; and rationale behind the &lt;span class=&quot;ext-link&quot;&gt;&lt;span class=&quot;icon&quot;&gt;osgViewer&lt;/span&gt;&lt;/span&gt; library. This page is meant to describe how to use the current Viewers and Views.&lt;/p&gt;
&lt;p&gt;When choosing an OpenSceneGraph provided Viewer, one has two choices: Viewer or CompositeViewer. Both are derived off of osgViewer::ViewerBase. ViewerBase provides functionality such as controlling stats, threading, and frame calls.&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;ext-link&quot;&gt;&lt;span class=&quot;icon&quot;&gt;Views&lt;/span&gt;&lt;/span&gt; themselves can contain multiple &lt;span class=&quot;ext-link&quot;&gt;&lt;span class=&quot;icon&quot;&gt;Cameras&lt;/span&gt;&lt;/span&gt;. Among other things, Views control a &lt;span class=&quot;ext-link&quot;&gt;&lt;span class=&quot;icon&quot;&gt;Scene&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;ext-link&quot;&gt;&lt;span class=&quot;icon&quot;&gt;DisplaySettings&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;ext-link&quot;&gt;&lt;span class=&quot;icon&quot;&gt;Event Handlers&lt;/span&gt;&lt;/span&gt;, and &lt;span class=&quot;ext-link&quot;&gt;&lt;span class=&quot;icon&quot;&gt;Camera Manipulators&lt;/span&gt;&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;ext-link&quot;&gt;&lt;span class=&quot;icon&quot;&gt;osgViewer::Viewer&lt;/span&gt;&lt;/span&gt; along with being a ViewerBase is also a View. This simplifies the setup and interface if one is interested in a single view.&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;ext-link&quot;&gt;&lt;span class=&quot;icon&quot;&gt;osgViewer::CompositeViewer&lt;/span&gt;&lt;/span&gt;, in contrast with Viewer, actually contains a list of multiple Views. This gives more versatility to the programmer but with more work to access View functionality.&lt;/p&gt;
&lt;h3 id=&quot;WhichViewertoUse&quot;&gt;Which Viewer to Use&lt;/h3&gt;
&lt;p&gt;So which Viewer class is right for your app? This is discussed in detail on &lt;a href=&quot;https://www.openscenegraph.com/index.php/documentation/guides/programming-guides/93-viewer-vs-compositeviewer&quot;&gt;this page&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;Windowing&quot;&gt;Windowing&lt;/h3&gt;
&lt;p&gt;Windows are created for each &lt;span class=&quot;ext-link&quot;&gt;&lt;span class=&quot;icon&quot;&gt;GraphicsContext&lt;/span&gt;&lt;/span&gt; created. When using some of helper funcions for osgView::View, such as setUpViewAcrossAllScreens(), setUpViewOnSingleScreen(), or setUpViewInWindow(), the graphics context with a new window will be created for each call. Therefore, using some combination of these calls with a CompositeViewer with multiple Views would produce multiple windows. If one did not want multiple windows or maybe didn't want window decorations, one can setup the &lt;span class=&quot;ext-link&quot;&gt;&lt;span class=&quot;icon&quot;&gt;Traits&lt;/span&gt;&lt;/span&gt; themselves. A single window with multiple views can be achieved by setting Traits::sharedContext to a previously created context. And, the decorations can be turned of with Traits::windowDecoration set to false.&lt;/p&gt;
&lt;p&gt;Examples of setting up windows and contexts can be found in the osgwindows and osgcamera examples among others.&lt;/p&gt;</summary>
		<content type="html">&lt;h3 id=&quot;BasicDescription&quot;&gt;Basic Description&lt;/h3&gt;
&lt;p&gt;There is a &lt;a href=&quot;http://www.openscenegraph.org/projects/osg/wiki/Community/Tasks/osgViewer&quot;&gt;history&lt;/a&gt; and rationale behind the &lt;span class=&quot;ext-link&quot;&gt;&lt;span class=&quot;icon&quot;&gt;osgViewer&lt;/span&gt;&lt;/span&gt; library. This page is meant to describe how to use the current Viewers and Views.&lt;/p&gt;
&lt;p&gt;When choosing an OpenSceneGraph provided Viewer, one has two choices: Viewer or CompositeViewer. Both are derived off of osgViewer::ViewerBase. ViewerBase provides functionality such as controlling stats, threading, and frame calls.&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;ext-link&quot;&gt;&lt;span class=&quot;icon&quot;&gt;Views&lt;/span&gt;&lt;/span&gt; themselves can contain multiple &lt;span class=&quot;ext-link&quot;&gt;&lt;span class=&quot;icon&quot;&gt;Cameras&lt;/span&gt;&lt;/span&gt;. Among other things, Views control a &lt;span class=&quot;ext-link&quot;&gt;&lt;span class=&quot;icon&quot;&gt;Scene&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;ext-link&quot;&gt;&lt;span class=&quot;icon&quot;&gt;DisplaySettings&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;ext-link&quot;&gt;&lt;span class=&quot;icon&quot;&gt;Event Handlers&lt;/span&gt;&lt;/span&gt;, and &lt;span class=&quot;ext-link&quot;&gt;&lt;span class=&quot;icon&quot;&gt;Camera Manipulators&lt;/span&gt;&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;ext-link&quot;&gt;&lt;span class=&quot;icon&quot;&gt;osgViewer::Viewer&lt;/span&gt;&lt;/span&gt; along with being a ViewerBase is also a View. This simplifies the setup and interface if one is interested in a single view.&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;ext-link&quot;&gt;&lt;span class=&quot;icon&quot;&gt;osgViewer::CompositeViewer&lt;/span&gt;&lt;/span&gt;, in contrast with Viewer, actually contains a list of multiple Views. This gives more versatility to the programmer but with more work to access View functionality.&lt;/p&gt;
&lt;h3 id=&quot;WhichViewertoUse&quot;&gt;Which Viewer to Use&lt;/h3&gt;
&lt;p&gt;So which Viewer class is right for your app? This is discussed in detail on &lt;a href=&quot;https://www.openscenegraph.com/index.php/documentation/guides/programming-guides/93-viewer-vs-compositeviewer&quot;&gt;this page&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;Windowing&quot;&gt;Windowing&lt;/h3&gt;
&lt;p&gt;Windows are created for each &lt;span class=&quot;ext-link&quot;&gt;&lt;span class=&quot;icon&quot;&gt;GraphicsContext&lt;/span&gt;&lt;/span&gt; created. When using some of helper funcions for osgView::View, such as setUpViewAcrossAllScreens(), setUpViewOnSingleScreen(), or setUpViewInWindow(), the graphics context with a new window will be created for each call. Therefore, using some combination of these calls with a CompositeViewer with multiple Views would produce multiple windows. If one did not want multiple windows or maybe didn't want window decorations, one can setup the &lt;span class=&quot;ext-link&quot;&gt;&lt;span class=&quot;icon&quot;&gt;Traits&lt;/span&gt;&lt;/span&gt; themselves. A single window with multiple views can be achieved by setting Traits::sharedContext to a previously created context. And, the decorations can be turned of with Traits::windowDecoration set to false.&lt;/p&gt;
&lt;p&gt;Examples of setting up windows and contexts can be found in the osgwindows and osgcamera examples among others.&lt;/p&gt;</content>
		<category term="Knowledge Base" />
	</entry>
	<entry>
		<title>What is a Scene Graph?</title>
		<link rel="alternate" type="text/html" href="https://www.openscenegraph.com/index.php/documentation/knowledge-base/36-what-is-a-scene-graph"/>
		<published>2012-05-12T01:26:38+00:00</published>
		<updated>2012-05-12T01:26:38+00:00</updated>
		<id>https://www.openscenegraph.com/index.php/documentation/knowledge-base/36-what-is-a-scene-graph</id>
		<author>
			<name>openscenegraph</name>
			<email>jtorresfabra@gmail.com</email>
		</author>
		<summary type="html">&lt;div id=&quot;content&quot; class=&quot;wiki&quot;&gt;
&lt;div class=&quot;wikipage searchable&quot;&gt;
&lt;p&gt;It's a tree! Quite simply it is one the best and most reusable data structures invented. Typically drawn schematically with the root at the top, and leaves at the bottom. It all starts with a top-most root node which encompasses your whole virtual world, be it 2D or 3D. The world is then broken down into a hierarchy of nodes representing either spatial groupings of objects, settings of the position of objects, animations of objects, or definitions of logical relationships between objects such as those to manage the various states of a traffic light. The leaves of the graph represent the physical objects themselves, the drawable geometry and their material properties.&lt;/p&gt;
&lt;p&gt;A scene graph isn't a complete game or simulation engine, although it may be one of the main components of such an engine; it's primary focus is representation of your 3d worlds, and efficient rendering thereof. Physics models, collision detection and audio are left to other development libraries that a user will integrate with. The fact that scene graphs don't typically integrate all these features is actually a really good thing: it aids interoprability with clients' own applications and tools and allows it to serve many varied markets from games, visual simulation, virtual reality, scientific and commercial visualization, training through to modeling programs.&lt;/p&gt;
&lt;h3 id=&quot;BenefitsthatSceneGraphsprovide&quot;&gt;Benefits that Scene Graphs provide&lt;/h3&gt;
&lt;p&gt;The key reasons that many graphics developers uses scene graphs are Performance, Productivity, Portability and Scalability:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Performance&lt;/strong&gt; Scene graphs provide an excellent framework for maximizing graphics performance. A good scene graph employs two key techniques - culling of the objects that won't be seen on screen, and state sorting of properties such as textures and materials, so that all similar objects are drawn together. Without culling the CPU, buses and GPU will all become swamped by many times the amount of data than they actually require to represent your scenes accurately. The hierarchical structure of the scene graph makes this culling process very efficient, for instance a whole city can be culled with just a few operations! Without state sorting, the buses and GPU will thrash between states, stalling the graphics pipeline and destroying graphics throughput. As GPU's get faster and faster, the cost of stalling the graphics pipeline is also going up, so scene graphs are becoming ever more important.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Productivity&lt;/strong&gt; Scene graphs take away much of the hard work required to develop high performance graphics applications. The scene graph manages all the graphics for you, reducing what would be thousands of lines of OpenGL down to a few simple calls. Furthermore, one of most powerful concepts in Object Oriented programming is that of object composition, enshrined in the Composite Design Pattern, which fits the scene graph tree structure perfectly and makes it a highly flexible and reusable design - in real terms this means that it can be easily adapted to solve your problems. Scene graphs also often come with additional utility libraries which range from helping users set up and manage graphics windows to importing of 3d models and images. All this together allows the user to achieve a great deal with very little coding. A dozen lines of code can be enough to load your data and create an interactive viewer!&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Portability&lt;/strong&gt; Scene graphs encapsulate much of the lower level tasks of rendering graphics and reading and writing data, reducing or even eradicating the platform specific coding that you require in your own application. If the underlying scene graph is portable then moving from platform to platform can be as simple as recompiling your source code.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Scalability&lt;/strong&gt; Along with being able to dynamic manage the complexity of scenes automatically to account for differences in graphics performance across a range of machines, scene graphs also make it much easier to manage complex hardware configurations, such as clusters of graphics machines, or multiprocessor/multipipe systems such as SGI's Onyx. A good scene graph will allow the developer to concentrate on developing their own application while the rendering framework of the scene graph handles the different underlying hardware configurations.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</summary>
		<content type="html">&lt;div id=&quot;content&quot; class=&quot;wiki&quot;&gt;
&lt;div class=&quot;wikipage searchable&quot;&gt;
&lt;p&gt;It's a tree! Quite simply it is one the best and most reusable data structures invented. Typically drawn schematically with the root at the top, and leaves at the bottom. It all starts with a top-most root node which encompasses your whole virtual world, be it 2D or 3D. The world is then broken down into a hierarchy of nodes representing either spatial groupings of objects, settings of the position of objects, animations of objects, or definitions of logical relationships between objects such as those to manage the various states of a traffic light. The leaves of the graph represent the physical objects themselves, the drawable geometry and their material properties.&lt;/p&gt;
&lt;p&gt;A scene graph isn't a complete game or simulation engine, although it may be one of the main components of such an engine; it's primary focus is representation of your 3d worlds, and efficient rendering thereof. Physics models, collision detection and audio are left to other development libraries that a user will integrate with. The fact that scene graphs don't typically integrate all these features is actually a really good thing: it aids interoprability with clients' own applications and tools and allows it to serve many varied markets from games, visual simulation, virtual reality, scientific and commercial visualization, training through to modeling programs.&lt;/p&gt;
&lt;h3 id=&quot;BenefitsthatSceneGraphsprovide&quot;&gt;Benefits that Scene Graphs provide&lt;/h3&gt;
&lt;p&gt;The key reasons that many graphics developers uses scene graphs are Performance, Productivity, Portability and Scalability:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Performance&lt;/strong&gt; Scene graphs provide an excellent framework for maximizing graphics performance. A good scene graph employs two key techniques - culling of the objects that won't be seen on screen, and state sorting of properties such as textures and materials, so that all similar objects are drawn together. Without culling the CPU, buses and GPU will all become swamped by many times the amount of data than they actually require to represent your scenes accurately. The hierarchical structure of the scene graph makes this culling process very efficient, for instance a whole city can be culled with just a few operations! Without state sorting, the buses and GPU will thrash between states, stalling the graphics pipeline and destroying graphics throughput. As GPU's get faster and faster, the cost of stalling the graphics pipeline is also going up, so scene graphs are becoming ever more important.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Productivity&lt;/strong&gt; Scene graphs take away much of the hard work required to develop high performance graphics applications. The scene graph manages all the graphics for you, reducing what would be thousands of lines of OpenGL down to a few simple calls. Furthermore, one of most powerful concepts in Object Oriented programming is that of object composition, enshrined in the Composite Design Pattern, which fits the scene graph tree structure perfectly and makes it a highly flexible and reusable design - in real terms this means that it can be easily adapted to solve your problems. Scene graphs also often come with additional utility libraries which range from helping users set up and manage graphics windows to importing of 3d models and images. All this together allows the user to achieve a great deal with very little coding. A dozen lines of code can be enough to load your data and create an interactive viewer!&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Portability&lt;/strong&gt; Scene graphs encapsulate much of the lower level tasks of rendering graphics and reading and writing data, reducing or even eradicating the platform specific coding that you require in your own application. If the underlying scene graph is portable then moving from platform to platform can be as simple as recompiling your source code.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Scalability&lt;/strong&gt; Along with being able to dynamic manage the complexity of scenes automatically to account for differences in graphics performance across a range of machines, scene graphs also make it much easier to manage complex hardware configurations, such as clusters of graphics machines, or multiprocessor/multipipe systems such as SGI's Onyx. A good scene graph will allow the developer to concentrate on developing their own application while the rendering framework of the scene graph handles the different underlying hardware configurations.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</content>
		<category term="Knowledge Base" />
	</entry>
</feed>
